import { Vec3 } from "./Vec3";
import { Quat } from "./Quat";
declare type Mat4DeterminantFunction = {
    f: {
        b00: number;
        b01: number;
        b02: number;
        b03: number;
        b04: number;
        b05: number;
        b06: number;
        b07: number;
        b08: number;
        b09: number;
        b10: number;
        b11: number;
    };
    determinant: number;
};
declare class Mat4 {
    #private;
    constructor(...args: number[]);
    reset(...args: number[]): Mat4;
    resetToMat4(m: Mat4): Mat4;
    clone(): Mat4;
    transpose(): Mat4;
    transposeNew(): Mat4;
    add(m: Mat4): Mat4;
    addNew(m: Mat4): Mat4;
    subtract(m: Mat4): Mat4;
    subtractNew(m: Mat4): Mat4;
    multiply(m: Mat4): Mat4;
    multiplyNew(m: Mat4): Mat4;
    multiplyScalar(s: number): Mat4;
    multiplyScalarNew(s: number): Mat4;
    scale(s: number): Mat4;
    scaleNew(s: number): Mat4;
    scaleByVec3(v: any): Mat4;
    scaleByVec3New(v: any): Mat4;
    /**
     * Transforms the mat4 by a given amount
     *
     * @param {Vec3} v The amount to add to the matrixes transformation properties
     * @returns {mat4} output
     */
    transform(v: any): Mat4;
    transformNew(v: any): Mat4;
    /**
     * Transforms the mat4 to a given position
     *
     * @param {Vec3} v The amount to add to the matrixes transformation properties
     * @returns {mat4} output
     */
    transformTo(v: any): Mat4;
    transformToNew(v: any): Mat4;
    /**
     * Rotates a mat4 by the given angle around the given axis
     *
     * @param {Number} r the angle to rotate the matrix by
     * @param {vec3} axis the axis to rotate around
     * @returns {mat4} output
     */
    rotate(r: number, axis: any): Mat4;
    rotateNew(r: number, axis: any): Mat4;
    invert(): Mat4;
    invertNew(): Mat4;
    toString(): string;
    set a11(v: number);
    get a11(): number;
    set a12(v: number);
    get a12(): number;
    set a13(v: number);
    get a13(): number;
    set a14(v: number);
    get a14(): number;
    set a21(v: number);
    get a21(): number;
    set a22(v: number);
    get a22(): number;
    set a23(v: number);
    get a23(): number;
    set a24(v: number);
    get a24(): number;
    set a31(v: number);
    get a31(): number;
    set a32(v: number);
    get a32(): number;
    set a33(v: number);
    get a33(): number;
    set a34(v: number);
    get a34(): number;
    set a41(v: number);
    get a41(): number;
    set a42(v: number);
    get a42(): number;
    set a43(v: number);
    get a43(): number;
    set a44(v: number);
    get a44(): number;
    get frobeniusnorm(): number;
    get translation(): Vec3;
    get scaling(): Vec3;
    get rotation(): Quat;
    /**
     * Calculates the determinant function the mat4
     *
     * @returns {Number} determinant of a
     */
    get determinantFunction(): Mat4DeterminantFunction;
    /**
     * Calculates the determinant of the mat4
     *
     * @returns {Number} determinant of a
     */
    get determinant(): number;
    /**
     * (getter) Returns the basic array representation of this matrix.
     * @readonly
     *
     * @type {array}
     */
    get array(): number[];
    static fromRotation(r: any, axis: any): Mat4;
    static fromXRotation(r: any): Mat4;
    static fromYRotation(r: any): Mat4;
    static fromZRotation(r: any): Mat4;
    static fromScalingVec3(v: any): Mat4;
    static fromTranslatingVec3(v: any): Mat4;
    /**
     * Calculates a 4x4 matrix from the given quaternion
     *
     * @param {quat} q Quaternion to create matrix from
     *
     * @returns {mat4} out
     */
    static fromQuat(q: any): Mat4;
    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     let quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *     mat4.scale(dest, scale)
     *
     * @param {quat4} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @param {vec3} s Scaling vector
     * @returns {mat4} out
     */
    static fromRotationTranslationScale(q: any, v: any, s: any): Mat4;
    /**
     * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     mat4.translate(dest, origin);
     *     let quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *     mat4.scale(dest, scale)
     *     mat4.translate(dest, negativeOrigin);
     *
     * @param {quat4} q Rotation quaternion
     * @param {vec3} v Translation vector
     * @param {vec3} s Scaling vector
     * @param {vec3} o The origin vector around which to scale and rotate
     * @returns {mat4} out
     */
    static fromRotationTranslationScaleOrigin(q: any, v: any, s: any, o: any): Mat4;
    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {Number} left Left bound of the frustum
     * @param {Number} right Right bound of the frustum
     * @param {Number} bottom Bottom bound of the frustum
     * @param {Number} top Top bound of the frustum
     * @param {Number} near Near bound of the frustum
     * @param {Number} far Far bound of the frustum
     * @returns {mat4} out
     */
    static frustum(left: any, right: any, bottom: any, top: any, near: any, far: any): Mat4;
    /**
     * Generates a perspective projection matrix with the given bounds.
     * Passing null/undefined/no value for far will generate infinite projection matrix.
     *
     * @param {number} fovy Vertical field of view in radians
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum, can be null or Infinity
     * @returns {mat4} out
     */
    static perspective(fovy: any, aspect: any, near: any, far: any): Mat4;
    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @returns {mat4} out
     */
    static ortho(left: any, right: any, bottom: any, top: any, near: any, far: any): Mat4;
    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis.
     * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
     *
     * @param {mat4} out mat4 frustum matrix will be written into
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing up
     * @returns {mat4} out
     */
    static lookAt(eye: any, center: any, up: any): Mat4;
    /**
     * Generates a matrix that makes something look at something else.
     *
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing up
     * @returns {mat4} out
     */
    static targetTo(eye: any, target: any, up: any): Mat4;
}
export { Mat4 };
