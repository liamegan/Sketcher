/** TO DO
 * Move these functions to a types file
 */
declare type Mat3DeterminantFunction = {
    f: {
        b01: number;
        b11: number;
        b21: number;
    };
    determinant: number;
};
declare type Mat4DeterminantFunction = {
    f: {
        b00: number;
        b01: number;
        b02: number;
        b03: number;
        b04: number;
        b05: number;
        b06: number;
        b07: number;
        b08: number;
        b09: number;
        b10: number;
        b11: number;
    };
    determinant: number;
};
interface Mat4 {
    a11: number;
    a12: number;
    a13: number;
    a14: number;
    a21: number;
    a22: number;
    a23: number;
    a24: number;
    a31: number;
    a32: number;
    a33: number;
    a34: number;
    a41: number;
    a42: number;
    a43: number;
    a44: number;
    determinantFunction: Mat4DeterminantFunction;
}
declare class Mat3 {
    #private;
    constructor(...args: number[]);
    reset(...args: number[]): Mat3;
    resetToMat3(m: Mat3): Mat3;
    clone(): Mat3;
    transpose(): Mat3;
    transposeNew(): Mat3;
    adjoint(): Mat3;
    adjointNew(): Mat3;
    add(m: Mat3): Mat3;
    addNew(m: Mat3): Mat3;
    subtract(m: Mat3): Mat3;
    subtractNew(m: Mat3): Mat3;
    multiply(m: Mat3): Mat3;
    multiplyNew(m: Mat3): Mat3;
    multiplyScalar(s: number): Mat3;
    multiplyScalarNew(s: number): Mat3;
    scale(s: number): Mat3;
    scaleNew(s: number): Mat3;
    scaleByVec2(v: any): Mat3;
    scaleByVec2New(v: any): Mat3;
    rotate(r: number): Mat3;
    rotateNew(r: number): Mat3;
    invert(): Mat3;
    invertNew(): Mat3;
    toString(): string;
    set a11(v: number);
    get a11(): number;
    set a12(v: number);
    get a12(): number;
    set a13(v: number);
    get a13(): number;
    set a21(v: number);
    get a21(): number;
    set a22(v: number);
    get a22(): number;
    set a23(v: number);
    get a23(): number;
    set a31(v: number);
    get a31(): number;
    set a32(v: number);
    get a32(): number;
    set a33(v: number);
    get a33(): number;
    get frobeniusnorm(): number;
    /**
     * (getter) Returns the basic array representation of this matrix.
     * @readonly
     *
     * @type {array}
     */
    get array(): number[];
    /**
     * (getter) Returns the basic array representation of this matrix.
     * this returns the array in column-major form.
     * @readonly
     *
     * @type {array}
     */
    get columnArray(): number[];
    get determinantFunction(): Mat3DeterminantFunction;
    /**
     * Calculates the determinant of the mat3
     *
     * @returns {Number} determinant of a
     */
    get determinant(): number;
    static fromAngle(r: number): Mat3;
    static fromScalingVec2(v: any): Mat3;
    static fromQuat(q: any): Mat3;
    /**
     * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
     *
     * @param {mat4} a Mat4 to derive the normal matrix from
     *
     * @returns {mat3}
     */
    static fromMat4(a: Mat4): Mat3;
    /**
     * Generates a 2D projection matrix with the given bounds
     *
     * @param {number} width Width of your gl context
     * @param {number} height Height of gl context
     * @returns {mat3} out
     */
    static fromProjection(width: number, height: number): Mat3;
    static identity(): Mat3;
}
export { Mat3 };
